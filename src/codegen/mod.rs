//! Code Generator Module
//! 
//! Generates Rust code from FSM definitions.
//! 
//! ## Available Targets
//! 
//! - **Standard** (MIT): Basic Rust FSM with states, events, and transitions
//! 
//! ### Premium Targets (Oxidate Pro)
//! 
//! The following targets are available in Oxidate Pro (available separately):
//! 
//! - **Embassy**: Async embedded with Active Object pattern
//! - **RTIC**: Real-time embedded with event queues
//! 
//! Contact:
//! - Issues: https://github.com/JoseClaudioSJr/Oxidate/issues
//! - Discussions: https://github.com/JoseClaudioSJr/Oxidate/discussions

use crate::fsm::FsmDefinition;

/// Code generation target
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodegenTarget {
    /// Standard Rust (std) - MIT licensed
    Standard,
    /// Embassy async (no_std, embedded) - Premium
    Embassy,
    /// RTIC (no_std, embedded) - Premium
    Rtic,
}

impl CodegenTarget {
    /// Check if target is available (premium features)
    pub fn is_available(&self) -> bool {
        match self {
            CodegenTarget::Standard => true,
            CodegenTarget::Embassy | CodegenTarget::Rtic => false, // Premium
        }
    }
    
    /// Get upgrade message for premium targets
    pub fn upgrade_message(&self) -> Option<&'static str> {
        match self {
            CodegenTarget::Standard => None,
            CodegenTarget::Embassy => Some(
                "Embassy code generation is available in Oxidate Pro.\n\
                 Contact: https://github.com/JoseClaudioSJr/Oxidate/discussions"
            ),
            CodegenTarget::Rtic => Some(
                "RTIC code generation is available in Oxidate Pro.\n\
                 Contact: https://github.com/JoseClaudioSJr/Oxidate/discussions"
            ),
        }
    }
}

impl Default for CodegenTarget {
    fn default() -> Self {
        Self::Standard
    }
}

/// Generate Rust code from an FSM definition
pub fn generate_rust_code(fsm: &FsmDefinition) -> String {
    generate_rust_code_with_target(fsm, CodegenTarget::Standard)
}

/// Generate Rust code with specific target
pub fn generate_rust_code_with_target(fsm: &FsmDefinition, target: CodegenTarget) -> String {
    match target {
        CodegenTarget::Standard => generate_standard_code(fsm),
        CodegenTarget::Embassy => generate_premium_stub(fsm, "Embassy"),
        CodegenTarget::Rtic => generate_premium_stub(fsm, "RTIC"),
    }
}

/// Generate stub for premium features
fn generate_premium_stub(fsm: &FsmDefinition, target_name: &str) -> String {
    format!(
        "//! {} code generation requires Oxidate Pro\n\
         //!\n\
         //! FSM: {}\n\
         //!\n\
         //! To generate {} code:\n\
         //!   1. Purchase/access: https://github.com/JoseClaudioSJr/Oxidate/discussions\n\
         //!   2. Then use: oxidate-pro generate --target {} your_fsm.fsm\n\
         //!\n\
         //! Oxidate Pro includes:\n\
         //!   - Embassy async Active Object pattern\n\
         //!   - RTIC real-time event queues\n\
         //!   - Events with payload\n\
         //!   - HSM hierarchical states\n\
         //!   - Priority support\n\
         \n\
         compile_error!(\"This target requires Oxidate Pro. Contact: https://github.com/JoseClaudioSJr/Oxidate/discussions\");\n",
        target_name,
        fsm.name,
        target_name,
        target_name.to_lowercase()
    )
}

// ============================================================================
// STANDARD CODE GENERATION
// ============================================================================

fn generate_standard_code(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    
    // Header
    code.push_str(&format!(
        "//! Auto-generated FSM: {}\n",
        fsm.name
    ));
    code.push_str("//! Generated by Oxidate\n\n");
    
    // Generate state enum
    code.push_str(&generate_state_enum(fsm));
    code.push_str("\n");
    
    // Generate event enum
    code.push_str(&generate_event_enum(fsm));
    code.push_str("\n");
    
    // Generate FSM struct
    code.push_str(&generate_fsm_struct(fsm));
    code.push_str("\n");
    
    // Generate implementation
    code.push_str(&generate_fsm_impl(fsm));
    code.push_str("\n");
    
    // Generate action trait
    code.push_str(&generate_action_trait(fsm));
    
    code
}

fn generate_state_enum(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    code.push_str(&format!("pub enum {}State {{\n", fsm.name));
    
    for state in &fsm.states {
        if let Some(ref desc) = state.description {
            code.push_str(&format!("    /// {}\n", desc));
        }
        code.push_str(&format!("    {},\n", to_pascal_case(&state.name)));
    }
    
    code.push_str("}\n");
    code
}

fn generate_event_enum(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    
    // Collect unique events
    let mut events: Vec<String> = fsm.transitions
        .iter()
        .filter_map(|t| t.event.as_ref().map(|e| e.name.clone()))
        .collect();
    events.sort();
    events.dedup();
    
    if events.is_empty() {
        return String::new();
    }
    
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    code.push_str(&format!("pub enum {}Event {{\n", fsm.name));
    
    for event in &events {
        code.push_str(&format!("    {},\n", to_pascal_case(event)));
    }
    
    code.push_str("}\n");
    code
}

fn generate_fsm_struct(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    
    code.push_str(&format!("pub struct {}<T: {}Actions> {{\n", fsm.name, fsm.name));
    code.push_str(&format!("    state: {}State,\n", fsm.name));
    code.push_str("    context: T,\n");
    code.push_str("}\n");
    
    code
}

fn generate_fsm_impl(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    
    let initial_state = fsm.initial_state.as_ref()
        .map(|s| to_pascal_case(s))
        .unwrap_or_else(|| "Unknown".to_string());
    
    code.push_str(&format!("impl<T: {}Actions> {}<T> {{\n", fsm.name, fsm.name));
    
    // Constructor
    code.push_str("    pub fn new(context: T) -> Self {\n");
    code.push_str(&format!("        Self {{\n"));
    code.push_str(&format!("            state: {}State::{},\n", fsm.name, initial_state));
    code.push_str("            context,\n");
    code.push_str("        }\n");
    code.push_str("    }\n\n");
    
    // State getter
    code.push_str(&format!("    pub fn state(&self) -> {}State {{\n", fsm.name));
    code.push_str("        self.state\n");
    code.push_str("    }\n\n");
    
    // Context getter
    code.push_str("    pub fn context(&self) -> &T {\n");
    code.push_str("        &self.context\n");
    code.push_str("    }\n\n");
    
    // Context mutable getter
    code.push_str("    pub fn context_mut(&mut self) -> &mut T {\n");
    code.push_str("        &mut self.context\n");
    code.push_str("    }\n\n");
    
    // Process event
    code.push_str(&generate_process_event(fsm));
    
    code.push_str("}\n");
    code
}

fn generate_process_event(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    
    code.push_str(&format!("    pub fn process(&mut self, event: {}Event) {{\n", fsm.name));
    code.push_str("        match (self.state, event) {\n");
    
    for transition in &fsm.transitions {
        if transition.source == "[*]" {
            continue; // Skip initial transitions
        }
        
        if let Some(ref event) = transition.event {
            let source = to_pascal_case(&transition.source);
            let target = to_pascal_case(&transition.target);
            let event_name = to_pascal_case(&event.name);
            
            // Check for guard
            if let Some(ref guard) = transition.guard {
                code.push_str(&format!(
                    "            ({}State::{}, {}Event::{}) if self.context.{} => {{\n",
                    fsm.name, source, fsm.name, event_name, to_snake_case(&guard.expression)
                ));
            } else {
                code.push_str(&format!(
                    "            ({}State::{}, {}Event::{}) => {{\n",
                    fsm.name, source, fsm.name, event_name
                ));
            }
            
            // Exit action
            if let Some(state) = fsm.states.iter().find(|s| s.name == transition.source) {
                if let Some(ref exit_action) = state.exit_action {
                    code.push_str(&format!(
                        "                self.context.{}();\n",
                        to_snake_case(&exit_action.name)
                    ));
                }
            }
            
            // Transition action
            if let Some(ref action) = transition.action {
                code.push_str(&format!(
                    "                self.context.{}();\n",
                    to_snake_case(&action.name)
                ));
            }
            
            // State change
            code.push_str(&format!(
                "                self.state = {}State::{};\n",
                fsm.name, target
            ));
            
            // Entry action
            if let Some(state) = fsm.states.iter().find(|s| s.name == transition.target) {
                if let Some(ref entry_action) = state.entry_action {
                    code.push_str(&format!(
                        "                self.context.{}();\n",
                        to_snake_case(&entry_action.name)
                    ));
                }
            }
            
            code.push_str("            }\n");
        }
    }
    
    // Default case - no transition
    code.push_str("            _ => {} // No transition\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    
    code
}

fn generate_action_trait(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    
    // Collect all actions
    let mut actions: Vec<String> = Vec::new();
    let mut guards: Vec<String> = Vec::new();
    
    for state in &fsm.states {
        if let Some(ref action) = state.entry_action {
            actions.push(action.name.clone());
        }
        if let Some(ref action) = state.exit_action {
            actions.push(action.name.clone());
        }
    }
    
    for transition in &fsm.transitions {
        if let Some(ref action) = transition.action {
            actions.push(action.name.clone());
        }
        if let Some(ref guard) = transition.guard {
            guards.push(guard.expression.clone());
        }
    }
    
    actions.sort();
    actions.dedup();
    guards.sort();
    guards.dedup();
    
    code.push_str(&format!("pub trait {}Actions {{\n", fsm.name));
    
    for action in &actions {
        code.push_str(&format!("    fn {}(&mut self);\n", to_snake_case(action)));
    }
    
    for guard in &guards {
        code.push_str(&format!("    fn {}(&self) -> bool;\n", to_snake_case(guard)));
    }
    
    code.push_str("}\n");
    
    code
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(c.to_lowercase().next().unwrap_or(c));
    }
    // Replace spaces and special chars
    result.replace(' ', "_").replace('-', "_")
}

// ============================================================================
// PREMIUM TARGETS (Embassy, RTIC)
// ============================================================================
// Available in Oxidate Pro (separately): https://github.com/JoseClaudioSJr/Oxidate/discussions
// 
// Features include:
// - Embassy Active Object pattern (async embedded)
// - RTIC real-time event queues
// - Events with typed payloads
// - HSM hierarchical states
// - Software timers
// - ISR-safe event posting
// ============================================================================