//! Premium Code Generation (Oxidate Pro)
//! 
//! This file contains the Embassy and RTIC code generators.
//! 
//! **NOT INCLUDED IN MIT RELEASE**
//! 
//! This file is maintained separately for Oxidate Pro.
//! Contact: GitHub Issues/Discussions

use crate::fsm::{FsmDefinition, StateType, Transition};

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(c.to_lowercase().next().unwrap_or(c));
    }
    result.replace(' ', "_").replace('-', "_")
}

// ============================================================================
// EMBASSY CODE GENERATION (Active Objects for async embedded)
// ============================================================================

pub fn generate_embassy_code(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    let name = &fsm.name;
    let name_lower = to_snake_case(name);
    
    // Header
    code.push_str(&format!("//! Auto-generated FSM: {} (Embassy Active Object)\n", name));
    code.push_str("//! Generated by Oxidate Pro - Active Object Pattern for Embedded\n");
    code.push_str("//! \n");
    code.push_str("//! Based on the Active Object design pattern (Lavender & Schmidt, 1996)\n");
    code.push_str("//!\n");
    code.push_str("//! Usage:\n");
    code.push_str("//!   1. Add to Cargo.toml: embassy-executor, embassy-sync, embassy-time\n");
    code.push_str("//!   2. Implement the Actions trait for your hardware\n");
    code.push_str("//!   3. Spawn the active object task\n\n");
    
    code.push_str("#![no_std]\n\n");
    code.push_str("use embassy_sync::channel::{Channel, Sender, Receiver};\n");
    code.push_str("use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;\n");
    code.push_str("use embassy_time::{Duration, Timer};\n\n");
    
    code.push_str("const EVENT_QUEUE_SIZE: usize = 8;\n\n");
    
    // State enum
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
    code.push_str("#[repr(u8)]\n");
    code.push_str(&format!("pub enum {}State {{\n", name));
    for state in &fsm.states {
        if let Some(ref desc) = state.description {
            code.push_str(&format!("    /// {}\n", desc));
        }
        code.push_str(&format!("    {},\n", to_pascal_case(&state.name)));
    }
    code.push_str("}\n\n");
    
    // ... rest of Embassy code generation
    // (Full implementation available in Oxidate Pro)
    
    code
}

// ============================================================================
// RTIC CODE GENERATION
// ============================================================================

pub fn generate_rtic_code(fsm: &FsmDefinition) -> String {
    let mut code = String::new();
    let name = &fsm.name;
    let name_lower = to_snake_case(name);
    
    // Header
    code.push_str(&format!("//! Auto-generated FSM: {} (RTIC)\n", name));
    code.push_str("//! Generated by Oxidate Pro - For RTIC v2 framework\n");
    code.push_str("//!\n");
    code.push_str("//! RTIC provides:\n");
    code.push_str("//! - Hardware tasks (interrupt handlers)\n");
    code.push_str("//! - Software tasks with priorities\n");
    code.push_str("//! - Zero-cost abstractions\n\n");
    
    code.push_str("#![no_std]\n\n");
    code.push_str("use heapless::spsc::Queue;\n\n");
    
    // State enum
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
    code.push_str("#[repr(u8)]\n");
    code.push_str(&format!("pub enum {}State {{\n", name));
    for state in &fsm.states {
        code.push_str(&format!("    {},\n", to_pascal_case(&state.name)));
    }
    code.push_str("}\n\n");
    
    // ... rest of RTIC code generation
    // (Full implementation available in Oxidate Pro)
    
    code
}
